apply plugin: 'release'

<<<<<<< HEAD
/*
 * Copyright 2013 Netflix, Inc.
 *
 *      Licensed under the Apache License, Version 2.0 (the "License");
 *      you may not use this file except in compliance with the License.
 *      You may obtain a copy of the License at
 *
 *          http://www.apache.org/licenses/LICENSE-2.0
 *
 *      Unless required by applicable law or agreed to in writing, software
 *      distributed under the License is distributed on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *      See the License for the specific language governing permissions and
 *      limitations under the License.
 */

// Ignore release plugin's task because it calls out via GradleBuild. This is a good place to put an email to send out
task release(overwrite: true, dependsOn: commitNewVersion) << {
    // This is a good place to put an email to send out
}
commitNewVersion.dependsOn updateVersion
updateVersion.dependsOn createReleaseTag
createReleaseTag.dependsOn preTagCommit
def buildTasks = tasks.matching { it.name =~ /:build/ }
preTagCommit.dependsOn buildTasks
preTagCommit.dependsOn checkSnapshotDependencies
//checkSnapshotDependencies.dependsOn confirmReleaseVersion // Introduced in 1.0, forces readLine
//confirmReleaseVersion.dependsOn unSnapshotVersion
checkSnapshotDependencies.dependsOn unSnapshotVersion // Remove once above is fixed
unSnapshotVersion.dependsOn checkUpdateNeeded
checkUpdateNeeded.dependsOn checkCommitNeeded
checkCommitNeeded.dependsOn initScmPlugin

[
    uploadIvyLocal: 'uploadLocal', 
    uploadArtifactory: 'artifactoryPublish', // Call out to compile against internal repository
    buildWithArtifactory: 'build' // Build against internal repository
].each { key, value ->
    // Call out to compile against internal repository
    task "${key}"(type: GradleBuild) {
        startParameter = project.gradle.startParameter.newInstance()
=======
[ uploadIvyLocal: 'uploadLocal', uploadArtifactory: 'artifactoryPublish', buildWithArtifactory: 'build' ].each { key, value ->
    // Call out to compile against internal repository
    task "${key}"(type: GradleBuild) {
        startParameter = project.gradle.startParameter.newInstance()
        doFirst {
            startParameter.projectProperties = [status: project.status, preferredStatus: project.status]
        }
>>>>>>> build/multi-project
        startParameter.addInitScript( file('gradle/netflix-oss.gradle') )
        startParameter.getExcludedTaskNames().add('check')
        tasks = [ 'build', value ]
    }
}
<<<<<<< HEAD
task releaseArtifactory(dependsOn: [checkSnapshotDependencies, uploadArtifactory])

// Ensure upload happens before taggging but after all pre-checks
releaseArtifactory.dependsOn checkSnapshotDependencies
createReleaseTag.dependsOn releaseArtifactory
gradle.taskGraph.whenReady { taskGraph ->
    if ( taskGraph.hasTask(uploadArtifactory) && rootProject.status == 'release' && !taskGraph.hasTask(':release') ) {
        throw new GradleException('"release" task has to be run before uploading a release to Artifactory')
    }
}
subprojects.each { project ->
    project.uploadMavenCentral.dependsOn rootProject.checkSnapshotDependencies
    rootProject.createReleaseTag.dependsOn project.uploadMavenCentral

    gradle.taskGraph.whenReady { taskGraph ->
        if ( taskGraph.hasTask(project.uploadMavenCentral) && !taskGraph.hasTask(':release') ) {
            throw new GradleException('"release" task has to be run before uploading to Maven Central')
        }
=======

// Marker task for following code to key in on
task releaseCandidate(dependsOn: release)
task forceCandidate {
    onlyIf { gradle.taskGraph.hasTask(releaseCandidate) }
    doFirst { project.status = 'candidate' }
}
task forceRelease {
    onlyIf { !gradle.taskGraph.hasTask(releaseCandidate) }
    doFirst { project.status = 'release' }
}
release.dependsOn([forceCandidate, forceRelease])

task uploadMavenCentral(dependsOn: subprojects.tasks.uploadMavenCentral)
task releaseSnapshot(dependsOn: [uploadArtifactory, uploadMavenCentral])

// Ensure our versions look like the project status before publishing
task verifyStatus << {
    def hasSnapshot = version.contains('-SNAPSHOT')
    if (project.status == 'snapshot' && !hasSnapshot) {
        throw new GradleException("Version (${version}) needs -SNAPSHOT if publishing snapshot")
    }
}
uploadArtifactory.dependsOn(verifyStatus)
uploadMavenCentral.dependsOn(verifyStatus)

// Ensure upload happens before taggging, hence upload failures will leave repo in a revertable state
preTagCommit.dependsOn([uploadArtifactory, uploadMavenCentral])


gradle.taskGraph.whenReady { taskGraph ->
    def hasRelease = taskGraph.hasTask('commitNewVersion')
    def indexOf = { return taskGraph.allTasks.indexOf(it) }

    if (hasRelease) {
        assert indexOf(build) < indexOf(unSnapshotVersion), 'build target has to be after unSnapshotVersion'
        assert indexOf(uploadMavenCentral) < indexOf(preTagCommit), 'preTagCommit has to be after uploadMavenCentral'
        assert indexOf(uploadArtifactory) < indexOf(preTagCommit), 'preTagCommit has to be after uploadArtifactory'
>>>>>>> build/multi-project
    }
}

// Prevent plugin from asking for a version number interactively
ext.'gradle.release.useAutomaticVersion' = "true"

release {
<<<<<<< HEAD
    // http://tellurianring.com/wiki/gradle/release
    failOnCommitNeeded=true
    failOnPublishNeeded=true
    failOnUnversionedFiles=true
    failOnUpdateNeeded=true
    includeProjectNameInTag=true
    requireBranch = null
=======
    git.requireBranch = null
>>>>>>> build/multi-project
}
